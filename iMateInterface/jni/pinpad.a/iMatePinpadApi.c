/* DO NOT EDIT THIS FILE - it is machine generated */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "KmyPinpadApi.h"
#include "XydPinpadApi.h"
#include "iMatePinpadApi.h"

#define COMM_NONE 			0
#define COMM_EVEN  			1
#define COMM_ODD  			2

#define PINPAD_BAUDRATE		9600L
#define PINPAD_PARITY		COMM_NONE

static int sg_pinpadModel = PINPAD_MODEL_KMY;

#ifndef __FOR_IOS__
// 设置Java虚拟机参数指针
// 使用说明：
// 在开始使用Memory之前调用该接口，按C结构方式将JavaVM变量传入接口
// JavaVM可以通过实现 JNI 的初始化函数 JNI_OnLoad 获取
void Pinpad_SetupJavaVM(JavaVM *vm)
{
    syncCommonSetVM(vm);
}
#endif

// 设置Pinpad型号
// in  : pinpadModel: PINPAD_MODEL_KMY,凯明扬密码键盘; PINPAD_MODEL_XYD,信雅达密码键盘
void Pinpad_SetPinpadModel(int pinpadModel)
{
	if (pinpadModel != PINPAD_MODEL_KMY && pinpadModel != PINPAD_MODEL_XYD)
		return;
	sg_pinpadModel = pinpadModel;
}

// 设置算法类型，用于下载masterkey或workingkey之前调用，仅用于信雅达的Pinpad
// in  : mode		: 主密钥类型包括，DECRYPT_KEY_MODE，ENCRYPT_KEY_MODE，PIN_KEY_MODE
void Pinpad_SetKeyMode(int mode)
{
	XydPinpad_SetKeyMode(mode);
}

// Pinpad上电
int Pinpad_PowerOn(void)
{
	unsigned char sendBytes[6];

	sendBytes[0] = 0x69;
	sendBytes[1] = 0x00;
	sendBytes[2] = 1;
	sendBytes[3] = PINPAD_BAUDRATE/256;
	sendBytes[4] = PINPAD_BAUDRATE%256;
	sendBytes[5] = PINPAD_PARITY;

	return syncCommonEx(sendBytes, 6, NULL, NULL, 1);
}

// Pinpad下电
int Pinpad_PowerOff(void)
{
	unsigned char sendBytes[3];

	sendBytes[0] = 0x69;
	sendBytes[1] = 0x00;
	sendBytes[2] = 2;

	return syncCommonEx(sendBytes, 6, NULL, NULL, 1);
}

// 设置密码键盘参数, 仅支持信雅达密码键盘
// in  : paramName	: 参数名称，
//					  "AuthCode", 认证密钥, 16字节长度, 缺省值为16个0x00
//					  "UID", Pinpad UID, 缺省值为{'1','2','3','4','5','6','7','8','9','0','1','2','3','4','5'}
//					  "WorkDirNum,子目录编号, 缺省值为1
//		 value		: 参数值，二进制形式
// ret : 0     		: 成功
//       1     		: 失败
void Pinpad_ParamSetup(char *paramName, unsigned char* value)
{
	if (sg_pinpadModel == PINPAD_MODEL_XYD)
		XydPinpad_ParamSetup(paramName, value);
}

// 取消密码输入操作，用于取消密码输入
void Pinpad_Cancel()
{
	if (sg_pinpadModel == PINPAD_MODEL_KMY) {
		KmyPinpad_Cancel();
	}
	if (sg_pinpadModel == PINPAD_MODEL_XYD) {
		XydPinpad_Cancel();
	}
}

// Pinpad复位自检
// in  : initFlag  	: 1-清除Pinpad中的密钥, 0-不清除密钥
// ret : 0			: 成功
//		 其它		: 失败
int Pinpad_Reset(int initFlag)
{
	if (sg_pinpadModel == PINPAD_MODEL_KMY)
		return KmyPinpad_Reset(initFlag);
	if (sg_pinpadModel == PINPAD_MODEL_XYD)
		return XydPinpad_Reset(initFlag);

	return -1;
}

// Pinpad固件版本号
// out : firmwareVersion  	: 版本号输出缓冲区，maxlength = 50
//		 versionLength		: 版本号长度
// ret : 0					: 成功
//		 其它				: 失败
int Pinpad_GetVersion(uchar *firmwareVersion, int *versionLength)
{
	if (sg_pinpadModel == PINPAD_MODEL_KMY)
		return KmyPinpad_GetVersion(firmwareVersion, versionLength);
	if (sg_pinpadModel == PINPAD_MODEL_XYD)
		return XydPinpad_GetVersion(firmwareVersion, versionLength);
	return -1;
}

// Pinpad下装主密钥
// in  : is3des  	: 是否采用3DES算法，false表示使用DES算法
//		 index		: 主密钥索引
//	     mastKey	: 主密钥
//		 keyLength	: 主密钥长度
// ret : 0			: 成功
//		 其它		: 失败
int Pinpad_DownloadMasterKey(int is3des, int index, unsigned char* masterKey, int keyLength)
{
	if (sg_pinpadModel == PINPAD_MODEL_KMY)
		return KmyPinpad_DownloadMasterKey(is3des, index, masterKey, keyLength);;
	if (sg_pinpadModel == PINPAD_MODEL_XYD)
		return XydPinpad_DownloadMasterKey(is3des, index, masterKey, keyLength);

	return -1;
}

// Pinpad下装工作密钥
// in  : is3des  		: 是否采用3DES算法，false表示使用DES算法
//		 index			: 主密钥索引
//	     mastKey		: 主密钥
//	     workingIndex	: 工作密钥索引
//		 keyLength		: 主密钥长度
// ret : 0				: 成功
//		 其它			: 失败
int Pinpad_DownloadWorkingKey(int is3des, int masterIndex, int workingIndex, unsigned char* workingKey, int keyLength)
{
	if (sg_pinpadModel == PINPAD_MODEL_KMY)
		return KmyPinpad_DownloadWorkingKey(is3des, masterIndex, workingIndex, workingKey, keyLength);
	if (sg_pinpadModel == PINPAD_MODEL_XYD)
		return XydPinpad_DownloadWorkingKey(is3des, masterIndex, workingIndex, workingKey, keyLength);

	return -1;
}

// Pinpad输入密码
// in  : is3des  		: 是否采用3DES算法，false表示使用DES算法
//		 isAutoReturn	: 输入pin长度后，是否自动返回
//	     masterIndex	: 主密钥索引
//	     workingIndex	: 工作密钥索引
//		 cardNo			: 卡号/帐号（最少12位数字）
//		 pinLength		: 需要输入PIN的长度
//		 timeout		: 输入密码等待超时时间 <= 255 秒
// out : pinblock		: pinpad输出的pinblock
// ret : 0				: 成功
//		 其它			: 失败
int Pinpad_InputPinblock(int is3des, int isAutoReturn, int masterIndex, int workingIndex, char* cardNo, int pinLength, unsigned char *pinblock, int timeout)
{

	if (sg_pinpadModel == PINPAD_MODEL_KMY)
		return KmyPinpad_InputPinblock(is3des, isAutoReturn, masterIndex, workingIndex, cardNo, pinLength, pinblock, timeout);
	if (sg_pinpadModel == PINPAD_MODEL_XYD)
		return XydPinpad_InputPinblock(is3des, isAutoReturn, masterIndex, workingIndex, cardNo, pinLength, pinblock, timeout);

	return -1;
}

// Pinpad加解密数据
// in  : is3des  		: 是否采用3DES算法，false表示使用DES算法
//		 algo			: 算法，取值: ALGO_ENCRYPT, ALGO_DECRYPT, 以ECB方式进行加解密运算
//		 masterIndex	: 主密钥索引
//	     workingIndex	: 工作密钥索引， 如果为-1，用masterKey进行加解密
//		 inData			: 加解密输入数据
//		 dataLength		: indata数据长度，必须为8的倍数
// out : outData		: 加解密输出的结果
// ret : 0				: 成功
//		 其它			: 失败
int Pinpad_Encrypt(int is3des, int algo, int masterIndex, int workingIndex, unsigned char*  inData, int dataLength, unsigned char * outData)
{
	if (sg_pinpadModel == PINPAD_MODEL_KMY)
		return KmyPinpad_Encrypt(is3des, algo, masterIndex, workingIndex, inData, dataLength, outData);
	if (sg_pinpadModel == PINPAD_MODEL_XYD)
		return XydPinpad_Encrypt(is3des, algo, masterIndex, workingIndex, inData, dataLength, outData);

	return -1;
}

// Pinpad数据MAC运算（ANSIX9.9）
// in  : is3des  		: 是否采用3DES算法，false表示使用DES算法
//		 masterIndex	: 主密钥索引
//	     workingIndex	: 工作密钥索引， 如果为-1，用masterKey进行加解密
//		 inData			: 加解密输入数据
//		 dataLength		: indata数据长度，必须为8的倍数
// out : outData		: MAC计算输出的结果
// ret : 0				: 成功
//		 其它			: 失败
int Pinpad_Mac(int is3des, int masterIndex, int workingIndex, unsigned char* data, int dataLength, unsigned char *mac)
{
	if (sg_pinpadModel == PINPAD_MODEL_KMY)
		return KmyPinpad_Mac(is3des, masterIndex, workingIndex, data, dataLength, mac);
	if (sg_pinpadModel == PINPAD_MODEL_XYD)
		return XydPinpad_Mac(is3des, masterIndex, workingIndex, data, dataLength, mac);

	return -1;
}

extern int syncCommon(unsigned char *sendData, int sendLength, unsigned char *receivedData, int *receivedLength, int timeout);

// 同步发送接收扩展，允许receivedData和receivedLength为null
int syncCommonEx(unsigned char *sendData, int sendLength, unsigned char *receivedData, int *receivedLength, int timeout)
{
#ifdef __FOR_IOS__
    unsigned char tmpBuffer[3096];
    int tmpReceivedLength;
    
    int ret = syncCommon(sendData, sendLength, tmpBuffer, &tmpReceivedLength, timeout);
    if (ret == 0) {
        if (receivedData != NULL)
            memcpy(receivedData, tmpBuffer, tmpReceivedLength);
        if (receivedLength != NULL)
            *receivedLength = tmpReceivedLength;
        
    }
    return ret;
#else
    return syncCommon(sendData, sendLength, receivedData, receivedLength, timeout);
#endif
}
