/* DO NOT EDIT THIS FILE - it is machine generated */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "KmyPinpadApi.h"
#include "iMatePinpadApi.h"

#ifndef __FOR_IOS__
#include "SyncCommon.h"
#else
extern int syncCommonEx(unsigned char *sendData, int sendLength, unsigned char *receivedData, int *receivedLength, int timeout);
extern void vOneTwo(const unsigned char *psIn, int iLength, unsigned char *psOut);
extern void vTwoOne(const unsigned char *psIn, int iLength, unsigned char *psOut);
#endif

static volatile int sg_CancelFlag = 0;

static int closePinpad(void) ;
static int kmyPinpadComm(uchar *in, int inLength, uchar *out, int *outLength, int timeout);

// 取消密码输入操作，用于取消密码输入
void KmyPinpad_Cancel(void)
{
	sg_CancelFlag = 1;
}

// Pinpad复位自检
// in  : initFlag  	: 1-清除Pinpad中的密钥, 0-不清除密钥
// ret : 0			: 成功
//		 其它		: 失败
int KmyPinpad_Reset(int initFlag)
{
	uchar sendBytes[2];

	sendBytes[0] = 0x31;
	sendBytes[1] = 0x38;
	int len = 1;
	if (initFlag)
		len = 2;
	return kmyPinpadComm(sendBytes, len, NULL, NULL, 1);
}

// Pinpad复位自检
// out : firmwareVersion  	: 版本号输出缓冲区，maxlength = 50
//		 versionLength		: 版本号长度
// ret : 0					: 成功
//		 其它				: 失败
int KmyPinpad_GetVersion(uchar *firmwareVersion, int *versionLength)
{
	uchar receivedBytes[50], sendBytes[1];

	sendBytes[0] = 0x30;

	int receivedLength = 0;
	int ret = kmyPinpadComm(sendBytes, 1, receivedBytes, &receivedLength, 1);
	if (ret)
		return ret;
	memcpy(firmwareVersion, receivedBytes, receivedLength);
	firmwareVersion[receivedLength] = 0;
	*versionLength = receivedLength;

	return 0;
}

// Pinpad下装主密钥
// in  : is3des  	: 是否采用3DES算法，false表示使用DES算法
//		 index		: 主密钥索引
//	     mastKey	: 主密钥
//		 keyLength	: 主密钥长度
// ret : 0			: 成功
//		 其它		: 失败
int KmyPinpad_DownloadMasterKey(int is3des, int index, unsigned char* masterKey, int keyLength)
{
	if (keyLength!=8 && keyLength != 16 && keyLength != 24)
		return 100;

	if (!is3des && keyLength!=8)
		return 101;

	uchar sendBytes[50];

	// 设置算法
	sendBytes[0] = 0x46;
	sendBytes[1] = 0;
	if (!is3des)
		sendBytes[2] = 0x20;
	else
		sendBytes[2] = 0x30;

	int ret = kmyPinpadComm(sendBytes, 3, NULL, NULL, 1);
	if (ret)
		return ret;

	int i;

	// 下载主密钥
	sendBytes[0] = 0x32;
	sendBytes[1] = index;
	for (i=0; i < keyLength; i++)
		sendBytes[2+i] = masterKey[i];

	return kmyPinpadComm(sendBytes, keyLength+2, NULL, NULL, 2);
}

// Pinpad下装工作密钥
// in  : is3des  		: 是否采用3DES算法，false表示使用DES算法
//		 index			: 主密钥索引
//	     mastKey		: 主密钥
//	     workingIndex	: 工作密钥索引
//		 keyLength		: 主密钥长度
// ret : 0				: 成功
//		 其它			: 失败
int KmyPinpad_DownloadWorkingKey(int is3des, int masterIndex, int workingIndex, unsigned char* workingKey, int keyLength)
{
	if (keyLength != 8 && keyLength != 16 && keyLength != 24)
		return 100;

	uchar sendBytes[50];

	// 设置算法
	sendBytes[0] = 0x46;
	sendBytes[1] = 0;
	if (!is3des)
		sendBytes[2] = 0x20;
	else
		sendBytes[2] = 0x30;

	int ret = kmyPinpadComm(sendBytes, 3, NULL, NULL, 1);
	if (ret)
		return ret;

	// 下载主密钥
	sendBytes[0] = 0x33;
	sendBytes[1] = masterIndex;
	sendBytes[2] = workingIndex;

	int i;
	for (i=0; i < keyLength; i++)
		sendBytes[3+i] = workingKey[i];

	return kmyPinpadComm(sendBytes, keyLength+3, NULL, NULL, 2);
}

// Pinpad输入密码
// in  : is3des  		: 是否采用3DES算法，false表示使用DES算法
//		 isAutoReturn	: 输入pin长度后，是否自动返回
//	     masterIndex	: 主密钥索引
//	     workingIndex	: 工作密钥索引
//		 cardNo			: 卡号/帐号（最少12位数字）
//		 pinLength		: 需要输入PIN的长度
//		 timeout		: 输入密码等待超时时间 <= 255 秒
// out : pinblock		: pinpad输出的pinblock
// ret : 0				: 成功
//		 其它			: 失败
int KmyPinpad_InputPinblock(int is3des, int isAutoReturn, int masterIndex, int workingIndex, char* cardNo, int pinLength, uchar *pinblock, int timeout)
{
	int finished = 0;

	sg_CancelFlag = 0;

	if (cardNo != NULL && strlen(cardNo) < 13)
		return 102;

	uchar receivedBytes[50];
	uchar sendBytes[50];

	// 复位自检
	sendBytes[0] = 0x31;
	int ret = kmyPinpadComm(sendBytes, 1, NULL, NULL, 1);
	if (ret)
        return ret;

    int i;
    uchar theCardNo[12];
    memset(theCardNo, '0', 12);
    if (cardNo != NULL) {
        int length = (uint)strlen(cardNo);
        for (i=0; i<12; i++)
            theCardNo[i] = cardNo[length+i-13];
    }
    
    //下装帐号
    sendBytes[0] = 0x34;
    memcpy(sendBytes + 1, theCardNo, 12);
    ret = kmyPinpadComm(sendBytes, 13, NULL, NULL, 1);
    if (ret)
        return ret;
    

	// 设置加密方式
	sendBytes[0] = 0x46;
	sendBytes[1] = 0x01;
	if (!is3des) {
		if (workingIndex < 0)
			sendBytes[2] = 0x60; //DES
		else
			sendBytes[2] = 0x20; //DES
	}
	else {
		if (workingIndex < 0)
			sendBytes[2] = 0x70; //3DES
		else
			sendBytes[2] = 0x30; //3DES
	}
	ret = kmyPinpadComm(sendBytes, 3, NULL, NULL, 1);
	if (ret)
		return ret;

	// 不自动加回车
	sendBytes[0] = 0x46;
	sendBytes[1] = 0x05;
	if (isAutoReturn)
		sendBytes[2] = 0x01;
	else
		sendBytes[2] = 0x00;
	ret = kmyPinpadComm(sendBytes, 13, NULL, NULL, 1);
	if (ret)
		return ret;

	// 激活工作密钥
	sendBytes[0] = 0x43;
	sendBytes[1] = masterIndex;

	if (workingIndex < 0)
		sendBytes[2] = 0;
	else
		sendBytes[2] = workingIndex;

	ret = kmyPinpadComm(sendBytes, 3, NULL, NULL, 2);
	if (ret)
		return ret;

	// 启动密码键盘
	sendBytes[0] = 0x35;
	sendBytes[1] = pinLength;
	sendBytes[2] = 0x01;	//显示*
    sendBytes[3] = 1; 		//与CardNo一起运算后加密
	sendBytes[4] = 0; 		//不提示
	sendBytes[5] = timeout;

	ret = kmyPinpadComm(sendBytes, 6, NULL, NULL, 2);
	if (ret)
		return ret;

	long tm = time(NULL) + timeout + 1;
    long tm2 = 0;

	while (time(NULL) < tm) {
    	if (sg_CancelFlag) {
    		sg_CancelFlag = 0;
    		closePinpad();
    		return 4;
    	}

		sendBytes[0] = 0x69;
		sendBytes[1] = 0x00;
		sendBytes[2] = 4;

		int receivedLength;
		ret = syncCommonEx(sendBytes, 3, receivedBytes, &receivedLength, 1);
		if (ret)
			return ret;

	    if (receivedLength > 1) {
	    	tm2 = time(NULL) + 5L;
	    }
	    if (tm2 > 0 && time(NULL) > tm2) {
			closePinpad();
			return 2;
	    }
	    for (i=1; i < receivedLength; i++) {
	    	if (receivedBytes[i] == 0x1b ) {
	    		closePinpad();
	    		return 4;
	    	}
	    	if (receivedBytes[i] == 8 ) {
	    		tm2 = 0;
	    		continue;
	    	}
	    	if (receivedBytes[i] == 0x0d ) {
	    		finished = 1;
	    		break;
	    	}
	    }
	    if ( finished)
	    	break;
	}
	if (!finished) {
		closePinpad();
		return 2;
	}

	// 获取密码密文
	sendBytes[0] = 0x42;
	int retLen = 0;

	ret = kmyPinpadComm(sendBytes, 1, receivedBytes, &retLen, 1);
	if (ret)
		return ret;

	if (retLen < 8)
		return 6;

	for (i=0; i<8; i++)
		pinblock[i] = receivedBytes[i];

	return 0;
}

// Pinpad加解密数据
// in  : is3des  		: 是否采用3DES算法，false表示使用DES算法
//		 algo			: 算法，取值: ALGO_ENCRYPT, ALGO_DECRYPT, 以ECB方式进行加解密运算
//		 masterIndex	: 主密钥索引
//	     workingIndex	: 工作密钥索引， 如果为-1，用masterKey进行加解密
//		 inData			: 加解密输入数据
//		 dataLength		: indata数据长度，必须为8的倍数
// out : outData		: 加解密输出的结果
// ret : 0				: 成功
//		 其它			: 失败
int KmyPinpad_Encrypt(int is3des, int algo, int masterIndex, int workingIndex, unsigned char*  inData, int dataLength, unsigned char * outData)
{
	if (dataLength%8 != 0 || dataLength > 248 )
		return 103;

	uchar receivedBytes[300];
	uchar sendBytes[300];

	// 设置算法
	sendBytes[0] = 0x46;
	sendBytes[1] = 1;
	if (!is3des) {
		if (workingIndex < 0)
			sendBytes[2] = 0x60;
		else
			sendBytes[2] = 0x20;
	}
	else {
		if (workingIndex < 0)
			sendBytes[2] = 0x70;
		else
			sendBytes[2] = 0x30;
	}
	int ret = kmyPinpadComm(sendBytes, 3, NULL, NULL, 2);
	if (ret)
		return ret;

	// 激活密钥
	sendBytes[0] = 0x43;
	sendBytes[1] = masterIndex;
	if (workingIndex < 0)
		sendBytes[2] = 0x00;
	else
		sendBytes[2] = workingIndex;

	ret = kmyPinpadComm(sendBytes, 3, NULL, NULL, 2);
	if (ret)
		return ret;

	// 启动加解密
	if (algo == ALGO_ENCRYPT)
		sendBytes[0] = 0x36;
	else
		sendBytes[0] = 0x37;
	int i;
	for (i=0; i<dataLength; i++) {
		sendBytes[i+1] = inData[i];
	}
	int retLength = 0;
	ret = kmyPinpadComm(sendBytes, 1+dataLength, receivedBytes, &retLength, 4);
	if (ret)
		return ret;
	if (retLength < 8 )
		return 6;

	for (i=0; i<retLength; i++)
		outData[i] = receivedBytes[i];

	return 0;

}

// Pinpad数据MAC运算（ANSIX9.9）
// in  : is3des  		: 是否采用3DES算法，false表示使用DES算法
//		 masterIndex	: 主密钥索引
//	     workingIndex	: 工作密钥索引， 如果为-1，用masterKey进行加解密
//		 inData			: 加解密输入数据
//		 dataLength		: indata数据长度，必须为8的倍数
// out : outData		: MAC计算输出的结果
// ret : 0				: 成功
//		 其它			: 失败
int KmyPinpad_Mac(int is3des, int masterIndex, int workingIndex, unsigned char* data, int dataLength, unsigned char *mac)
{
	if (dataLength <4 || dataLength > 246 )
		return 103;

	uchar receivedBytes[300];
	uchar sendBytes[300];

	sendBytes[0] = 0x46;
	sendBytes[1] = 1;
	if (!is3des) {
		if (workingIndex < 0)
			sendBytes[2] = 0x60;
		else
			sendBytes[2] = 0x20;
	}
	else {
		if (workingIndex < 0)
			sendBytes[2] = 0x70;
		else
			sendBytes[2] = 0x30;
	}
	int ret = kmyPinpadComm(sendBytes, 3, NULL, NULL, 2);
	if (ret)
		return ret;

	// 激活密钥
	sendBytes[0] = 0x43;
	sendBytes[1] = masterIndex;
	if (workingIndex < 0)
		sendBytes[2] = 0x00;
	else
		sendBytes[2] = workingIndex;

	ret = kmyPinpadComm(sendBytes, 3, NULL, NULL, 1);
	if (ret)
		return ret;

	// 启动计算Mac
	sendBytes[0] = 0x41;

	int i;
	for (i=0; i<dataLength; i++) {
		sendBytes[i+1] =  data[i];
	}
	int retLength = 0;
	ret = kmyPinpadComm(sendBytes, 1+dataLength, receivedBytes, &retLength, 4);
	if (ret)
		return ret;
	if (retLength < 8)
		return 6;

	for (i=0; i<8; i++)
		mac[i] = receivedBytes[i];

	return 0;
}

static int closePinpad(void)
{
	uchar sendBytes[2];
	// 关闭密码键盘
	sendBytes[0] = 0x45;
	sendBytes[1] = 0x00;

	return kmyPinpadComm(sendBytes, 2, NULL, NULL, 2);
}

static int toupper(int in) {
	if (in >= 'a' && in <= 'z')
		return in+32;
	return in;
}

static int twoOneInt(uchar *in, int offset)
{
	int tmp, ret;

	tmp = in[offset];
	if (tmp > '9')
		tmp = toupper(tmp) - 'A' + 0x0a;
	else
		tmp &= 0x0f;

	ret = (uchar)(tmp << 4);

	tmp = in[1+offset];
	if (tmp > '9')
		tmp = toupper(tmp) - 'A' + 0x0a;
	else
		tmp &= 0x0f;
	ret += tmp;

	return ret;
}

static int kmyPinpadComm(uchar *in, int inLength, uchar *out, int *outLength, int timeout)
{
	uchar receivedBytes[600];
	uchar sendBytes[600];
    int i;

	uchar bcc = (uchar)inLength;
	for (i=0; i<inLength; i++)
		bcc ^= in[i];
    
    uchar tmpBuf[300];
    tmpBuf[0] = inLength;
    memcpy(tmpBuf + 1, in, inLength);
    tmpBuf[1+inLength] = bcc;

	uchar packDataString[600];
    
    vOneTwo(tmpBuf, inLength + 2, packDataString);

	int packLength = 1 + (inLength+2) * 2;
	sendBytes[0] = 0x69;
	sendBytes[1] = 0x00;
	sendBytes[2] = 3; //发送数据报文命令
	sendBytes[3] = packLength/256;
	sendBytes[4] = packLength%256;
	sendBytes[5] = 0x02;
	for (i=0; i<(inLength+2)*2; i++)
		sendBytes[i+6] = packDataString[i];

	int ret = syncCommonEx(sendBytes, 5+packLength, NULL, NULL, 1);
	if (ret)
		return ret;

	long m = time(NULL) + timeout;
	int receivedLength = 0;
	int finished = 0;
	int receivePackLength = 0;
	while (time(NULL) < m) {
		sendBytes[0] = 0x69;
		sendBytes[1] = 0x00;
		sendBytes[2] = 4;

		uchar tmpBytes[600];
        int theLen;
		int ret = syncCommonEx(sendBytes, 3, tmpBytes, &theLen, 1);
		if (ret)
			return ret;

		if (tmpBytes[0] != 0)
			return 1;

		if (theLen <= 1) {
			continue;
		}

		for (i=0; i<theLen; i++) {
			receivedBytes[receivedLength+i] = tmpBytes[i+1];
		}
		receivedLength += theLen-1;

		if (receivedLength < 3)
			continue;

		if (receivedBytes[0] == 0x02 ) {
			int length = twoOneInt(receivedBytes, 1);
			if ((length+2)*2+1 == receivedLength) {
				receivePackLength = length;
				finished = 1;
				break;
			}
		}
	}
	if (!finished)
		return 2;

	int pinpadRet = twoOneInt(receivedBytes, 3);
	if (pinpadRet != 4 && pinpadRet != 0xa4) {
		return 3;
	}
	int retLength = receivePackLength-1;

	if (retLength >0 && out != NULL) {
		vTwoOne(receivedBytes + 5, retLength*2, out);
		*outLength = retLength;
	}
	return 0;
}


