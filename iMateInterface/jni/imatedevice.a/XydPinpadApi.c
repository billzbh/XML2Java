/* DO NOT EDIT THIS FILE - it is machine generated */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "XydPinpadApi.h"
#include "iMatePinpadApi.h"
#include "fdes.h"
#include "pub.h"

#define ENCRYPT     1
#define DECRYPT     2

static int workDirNum = 1;
static volatile int sg_CancelFlag = 0;

static uchar transferKey[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
static uchar authCodeKey[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
static uchar uid[] = {0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35};

static int keyMode = PIN_KEY_MODE;

static int xydPinpadComm(uchar *in, int inLength, uchar *out, int *outLength, int timeout);
static int changeDir(int dirNum);
static void pinpadDisp(int clearScreen, int alignment, int antiShow, int lineNum, char* displayString);
static int getAuthCode(uchar* data, int startIndex, int dataLength, uchar mode, uchar *authCode);
static void encryptMode(uchar *sSource, uchar *sKey, uchar *sResult);

// 设置密码键盘参数, 仅支持信雅达密码键盘
// in  : paramName	: 参数名称，
//					  "AuthCode", 认证密钥, 16字节长度, 缺省值为16个0x00
//					  "UID", Pinpad UID, 缺省值为{'1','2','3','4','5','6','7','8','9','0','1','2','3','4','5'}
//					  "WorkDirNum",子目录编号, 缺省值为1
//		 value		: 参数值，二进制形式, AuthCode和UID长度为16，WorkDirNum长度为1
// ret : 0     		: 成功
//       1     		: 失败
void XydPinpad_ParamSetup(char *paramName, unsigned char* value)
{
	int i;

	if (strcmp("AuthCode", paramName) == 0 && value) {
		for (i = 0; i < 16; i++) {
			authCodeKey[i] = value[i];
		}
	}
	if (strcmp("UID", paramName) == 0 && value) {
		for (i = 0; i < 16; i++) {
			uid[i] = value[i];
		}
	}
	if (strcmp("WorkDirNum", paramName) == 0 && value) {
		workDirNum = value[0];
	}
}

// 取消密码输入操作，用于取消密码输入
void XydPinpad_Cancel(void)
{
	sg_CancelFlag = 1;
}

// Pinpad复位自检
// in  : initFlag  	: 1-清除Pinpad中的密钥, 0-不清除密钥
// ret : 0			: 成功
//		 其它		: 失败
int XydPinpad_Reset(int initFlag)
{
	uchar sendBytes[3];
	sendBytes[0] = 0xD5;
	sendBytes[1] = 0x00;

	int ret = xydPinpadComm(sendBytes, sendBytes[1] + 2, NULL, NULL, 2);
	if (ret)
		return ret;
	return 0;
}

// Pinpad固件版本号
// out : firmwareVersion  	: 版本号输出缓冲区，maxlength = 50
//		 versionLength		: 版本号长度
// ret : 0					: 成功
//		 其它				: 失败
int XydPinpad_GetVersion(uchar *firmwareVersion, int *versionLength)
{
	uchar receivedBytes[100];
	uchar sendBytes[3];

	sendBytes[0] = 0x90;
	sendBytes[1] = 0x00;

	int receivedLength = 0;
	int ret = xydPinpadComm(sendBytes, 2, receivedBytes, &receivedLength, 2);
	if (ret)
		return ret;

	if (receivedLength <= 0)
		return 110;

	memcpy(firmwareVersion, receivedBytes, receivedLength);
	*versionLength = receivedLength;
	firmwareVersion[receivedLength] = 0;

	return 0;
}

// 设置算法类型，用于下载masterkey或workingkey之前调用，仅用于信雅达的Pinpad
// in  : mode		: 主密钥类型包括，DECRYPT_KEY_MODE，ENCRYPT_KEY_MODE，PIN_KEY_MODE
void XydPinpad_SetKeyMode(int mode)
{
	keyMode = mode;
}

// Pinpad下装主密钥
// in  : is3des  	: 是否采用3DES算法，false表示使用DES算法
//		 index		: 主密钥索引
//	     mastKey	: 主密钥
//		 keyLength	: 主密钥长度
// ret : 0			: 成功
//		 其它		: 失败
int XydPinpad_DownloadMasterKey(int is3des, int index, unsigned char* masterKey, int keyLength)
{
	int ret = changeDir(workDirNum);
	if (ret)
		return ret;

	uchar downloadMode = keyMode;
	if (keyLength > 8)
		downloadMode |= 0x80;

	if (keyLength!=8 && keyLength != 16 && keyLength != 24)
		return 102;

	uchar sendBytes[50];
	uchar receivedBytes[20];

	int tmp = 0, i;
	//下载主密钥
	sendBytes[tmp++] = 0x80;
	sendBytes[tmp++] = 0x0A + keyLength;
	sendBytes[tmp++] = index;
	sendBytes[tmp++] = downloadMode;


	uchar cipherMasterKey[keyLength];

	encryptMode(masterKey, transferKey, cipherMasterKey);

	if ( keyLength ==16 ) {
		encryptMode(masterKey, transferKey, cipherMasterKey + 8);
	}

	for(i = 0; i < keyLength; i++){
		sendBytes[tmp++] = cipherMasterKey[i];
	}

	uchar authCode[8];
	ret = getAuthCode(sendBytes, 2, sendBytes[1] - 8, 0x01, authCode);
	if (ret)
		return ret;

	for(i = 0; i < 8; i ++){
		sendBytes[tmp++] = authCode[i];
	}

	int receivedLength = 0;
	ret = xydPinpadComm(sendBytes, sendBytes[1] + 2, receivedBytes, &receivedLength, 2);
	if (ret)
		return ret;

	if (receivedLength <= 0)
		return 6;

	return 0;
}

// Pinpad下装工作密钥
// in  : is3des  		: 是否采用3DES算法，false表示使用DES算法
//		 index			: 主密钥索引
//	     mastKey		: 主密钥
//	     workingIndex	: 工作密钥索引
//		 keyLength		: 主密钥长度
// ret : 0				: 成功
//		 其它			: 失败
int XydPinpad_DownloadWorkingKey(int is3des, int masterIndex, int workingIndex, unsigned char* workingKey, int keyLength)
{
	int ret = changeDir(workDirNum);
	if (ret)
		return ret;

	uchar downloadMode = keyMode;
	if (is3des)
		downloadMode |= 0x10;
	if (keyLength > 8)
		downloadMode |= 0x80;

	if (keyLength != 8 && keyLength != 16 && keyLength != 24)
		return 102;

	uchar sendBytes[50];
	uchar receivedBytes[20];

	int tmp = 0, i;
	//下载工作密钥
	sendBytes[tmp++] = 0x81;
	sendBytes[tmp++] = (13 + keyLength);
	sendBytes[tmp++] = masterIndex;
	sendBytes[tmp++] = workingIndex;
	sendBytes[tmp++] = downloadMode;

	for(i = 0; i < keyLength; i++){
		sendBytes[tmp++] = workingKey[i];
	}

	uchar useNo[2] = {0x7f, 0xff};
	sendBytes[tmp++] = useNo[0];
	sendBytes[tmp++] = useNo[1];

	uchar authCode[8];
	ret = getAuthCode(sendBytes, 2, sendBytes[1] - 8, 0x01, authCode);
	if (ret)
		return ret;

	for(i = 0; i < 8; i ++){
		sendBytes[tmp++] = authCode[i];
	}

	int receivedLength = 0;
	ret = xydPinpadComm(sendBytes, sendBytes[1] + 2, receivedBytes, &receivedLength, 2);
	if (ret)
		return ret;

	if (receivedLength <= 0)
		return 6;

	return 0;
}

// Pinpad输入密码
// in  : is3des  		: 是否采用3DES算法，false表示使用DES算法
//		 isAutoReturn	: 输入pin长度后，是否自动返回
//	     masterIndex	: 主密钥索引
//	     workingIndex	: 工作密钥索引
//		 cardNo			: 卡号/帐号（最少12位数字）
//		 pinLength		: 需要输入PIN的长度
//		 timeout		: 输入密码等待超时时间 <= 255 秒
// out : pinblock		: pinpad输出的pinblock
// ret : 0				: 成功
//		 其它			: 失败
int XydPinpad_InputPinblock(int is3des, int isAutoReturn, int masterIndex, int workingIndex, char* cardNo, int pinLength, unsigned char *pinblock, int timeout)
{
	if (cardNo == NULL || strlen(cardNo) < 13)
		return 103;

	int ret = changeDir(workDirNum);
	if (ret)
		return ret;

	pinpadDisp(1, 1, 0, 1, "Entry the PIN");

	uchar receivedBytes[50];
	uchar sendBytes[50];

	int tmp = 0, i;

	//pin输入
	sendBytes[tmp++] = 0x8A;

	//数据长度
	sendBytes[tmp++] = 0x1e;

	//加密类型
	if (is3des)
		sendBytes[tmp++] = 0x82;
	else
		sendBytes[tmp++] = 0x02;

	//pin key id
	sendBytes[tmp++] = workingIndex;

	//use cnt
	sendBytes[tmp++] = (timeout / 255);
	sendBytes[tmp++] = (timeout % 255);

	//input min length
	sendBytes[tmp++] = pinLength;

	//input max length
	sendBytes[tmp++] = pinLength;

	//card no
	int accLen = (int)strlen(cardNo);
	int accOffset = 0;
	if (accLen > 13)
		accOffset = accLen - 13;

	for(i = 0; i < 16; i++) {
		if (i >= 4)
			sendBytes[tmp++] =  cardNo[accOffset++];
		else
			sendBytes[tmp++] = '1';
	}

	char authCode[8];
	ret = getAuthCode(sendBytes, 2, sendBytes[1] - 8, 0x01, authCode);
	if (ret)
		return ret;

	for(i = 0; i < 8; i ++){
		sendBytes[i + sendBytes[1] - 8 + 2] = authCode[i];
	}

	int receivedLength = 0;
	ret = xydPinpadComm(sendBytes, sendBytes[1] + 2, receivedBytes, &receivedLength, timeout + 1);
	if (ret)
		return ret;

	if (receivedLength <= 0)
		return 7;

	if (receivedLength <= 8)
		return 7; //取消

	for (i=0; i<receivedLength - 8; i++)
		pinblock[i] = receivedBytes[i];

	return 0;
}

// Pinpad加解密数据
// in  : is3des  		: 是否采用3DES算法，false表示使用DES算法
//		 algo			: 算法，取值: ALGO_ENCRYPT, ALGO_DECRYPT, 以ECB方式进行加解密运算
//		 masterIndex	: 主密钥索引
//	     workingIndex	: 工作密钥索引， 如果为-1，用masterKey进行加解密
//		 inData			: 加解密输入数据
//		 dataLength		: indata数据长度，必须为8的倍数
// out : outData		: 加解密输出的结果
// ret : 0				: 成功
//		 其它			: 失败
int XydPinpad_Encrypt(int is3des, int algo, int masterIndex, int workingIndex, uchar*  inData, int dataLength, uchar * outData)
{
	if ((dataLength % 8) != 0 )
		return 102;

	int ret = changeDir(workDirNum);
	if (ret)
		return ret;

	uchar receivedBytes[50];
	uchar sendBytes[50];

	uchar encMode = 0;
	if (algo == ALGO_DECRYPT)
		encMode = 0x80;
	if (is3des) {
		encMode |= 0x03;
	}
	else {
		encMode |= 0x01;
	}

	int i,j;
	// DES/3DES 加解密
	int retLength = 0;
	for(j = 0; j < dataLength; j += 8){
		int tmp = 0;
		sendBytes[tmp++] = 0x87;
		sendBytes[tmp++] = 0x0A;
		sendBytes[tmp++] = workingIndex;
		sendBytes[tmp++] = encMode;
		for(i = 0; i < 8; i++){
			sendBytes[tmp++] = inData[j + i];
		}
		int recvLength = 0;
		ret = xydPinpadComm(sendBytes, sendBytes[1] + 2, receivedBytes, &recvLength, 2);
		if (ret)
			return ret;

		if(encMode != 0x82){
			if (recvLength % 8  != 0)
				//throw new Exception("加解密数据失败");
				return 6;
		}else{
			if (recvLength % 18  != 0)
			//throw new Exception("dukpt 加解密数据失败");
				return 6;
		}
		for (i=0; i<recvLength; i++){
			outData[i + retLength] = receivedBytes[i];
		}
		retLength += recvLength;
	}
	if(retLength == 0){
		//throw new Exception("加解密数据失败");
		return 7;
	}

	return 0;
}

// Pinpad数据MAC运算（ANSIX9.9）
// in  : is3des  		: 是否采用3DES算法，false表示使用DES算法
//		 masterIndex	: 主密钥索引
//	     workingIndex	: 工作密钥索引， 如果为-1，用masterKey进行加解密
//		 inData			: 加解密输入数据
//		 dataLength		: indata数据长度，必须为8的倍数
// out : outData		: MAC计算输出的结果
// ret : 0				: 成功
//		 其它			: 失败
int XydPinpad_Mac(int is3des, int masterIndex, int workingIndex, unsigned char* data, int dataLength, unsigned char *mac)
{
	if ((dataLength % 8) != 0 || dataLength >= 246 )
		return 102;

	int ret = changeDir(workDirNum);
	if (ret)
		return ret;

	uchar receivedBytes[300];
	uchar sendBytes[300];

	uchar encMode = 0x01;
	if (is3des)
		encMode = 0x03;

	int tmp = 0, i;
	sendBytes[tmp++] =  0x85;
	sendBytes[tmp++] = (10 + dataLength);
	sendBytes[tmp++] = (workingIndex);
	sendBytes[tmp++] = encMode;

	for(i = 0; i< dataLength; i++){
		sendBytes[tmp++] = data[i];
	}

	uchar authCode[8];
	ret = getAuthCode(sendBytes, 2, sendBytes[1] - 8, 0x01, authCode);

	for(i = 0; i < 8; i ++){
		sendBytes[tmp++] = authCode[i];
	}
	int receivedLength = 0;
	ret = xydPinpadComm(sendBytes, sendBytes[1] + 2, receivedBytes, &receivedLength, 2);
	if (ret)
		return ret;

	if (receivedLength <= 0)
		return 6;

	memcpy(mac, receivedBytes, 8);

	return 0;
}

static void pininputCancel(void)
{
	uchar sendBytes[20];

	sendBytes[0] = 0x69;
	sendBytes[1] = 0x00;
	sendBytes[2] = 3;		//发送数据报文命令

	sendBytes[3] = 0;
	sendBytes[4] = 3;
	sendBytes[5] = 0x8E; //cancel command
	sendBytes[6] = 0x00; //data length
	sendBytes[7] = 0x8E; //bcc

	int ret = syncCommon(sendBytes, 8, NULL, NULL, 1);
	if (ret)
		return;

	sendBytes[0] = 0x69;
	sendBytes[1] = 0x00;
	sendBytes[2] = 4;
	syncCommon(sendBytes, 3, NULL, NULL, 1);
}

static int xydPinpadComm(uchar *in, int inLength, uchar *out, int *outLength, int timeout)
{
	sg_CancelFlag = 0;

	uchar receivedBytes[600];
	uchar sendBytes[600];
	uchar chkCMD = in[0];
	uchar bcc = 0x00;

	int i;
	for (i=0; i<inLength; i++)
		bcc ^= in[i];

	sendBytes[0] = 0x69;
	sendBytes[1] = 0x00;
	sendBytes[2] = 3;		//发送数据报文命令
	sendBytes[3] = (inLength + 1)/256;
	sendBytes[4] = (inLength + 1)%256;
	for (i=0; i<inLength; i++)
		sendBytes[i+5] = in[i];
	sendBytes[5 + inLength] = bcc;

	int ret = syncCommon(sendBytes, 5 + inLength + 1, NULL, NULL, 1);
	if (ret)
		return -1;

	long m = time(NULL) + timeout + 1;
	int receivedLength = 0;
	int finished = 0;
	int receivePackLength = 0;
	uchar tmpBytes[600];
	while (time(NULL) < m) {
		if (sg_CancelFlag) {
			pininputCancel();
			sg_CancelFlag = 0;
			return 4;
		}

		sendBytes[0] = 0x69;
		sendBytes[1] = 0x00;
		sendBytes[2] = 4;

        int theLen;
		ret = syncCommon(sendBytes, 3, tmpBytes, &theLen, 1);
		if (ret)
			return -1;
        
		if (tmpBytes[0] != 0)
			return 3;

		if (theLen <= 1) {
			continue;
		}
		//System.out.println("ret = " + (ret -1));
		for (i=0; i<theLen-1; i++) {
			receivedBytes[receivedLength+i] = tmpBytes[i+1];
			//System.out.format("%02X ", tmpBytes[i +1]);
		}
		//System.out.println();
		receivedLength += theLen-1;
		if((chkCMD >= 0xB0 && chkCMD <= 0xB5) || (chkCMD >= 0xE0 && chkCMD <= 0xE8)){
			if (receivedLength != receivedBytes[1] *256 + receivedBytes[2] + 4)
				continue;
		}else{
			if (receivedLength != receivedBytes[1] + 3)
				continue;
		}


		//if (receivedBytes[0] == chkCMD ) {
			finished = 1;
			break;
	   // }
	}
	if (!finished)
		return 2;

	if(receivedBytes[0] != chkCMD){
		uchar errorCode;
		if((chkCMD >= 0xB0 && chkCMD <= 0xB5) || (chkCMD >= 0xE0 && chkCMD <= 0xE8)){
			errorCode = receivedBytes[3];
			if(chkCMD ==0xB4 || chkCMD == 0xB3) //{
				return 7;
				//throw new Exception(piccError(errorCode));
			//}else{
				//throw new Exception(pinpadError(errorCode));
			//}
		//}else{
			//errorCode = receivedBytes[2];
			//throw new Exception(pinpadError(errorCode));
		}
	}

	if (out != NULL) {
		if((chkCMD >= 0xB0 && chkCMD <= 0xB5) || (chkCMD >= 0xE0 && chkCMD <= 0xE8)){
			*outLength = receivedBytes[1] * 256 + receivedBytes[2];
			for(i = 0; i < receivePackLength; i++){
				out[i] = receivedBytes[i + 3];
			}
		}else{
			*outLength = receivedBytes[1];
			for(i = 0; i < receivePackLength; i++){
				out[i] = receivedBytes[i + 2];
			}
		}
	}
	return 0;
}

static int changeDir(int dirNum)
{
	uchar sendBytes[3];

	sendBytes[0] = 0xD6;
	sendBytes[1] = 0x01;
	sendBytes[2] = dirNum;

	int ret = xydPinpadComm(sendBytes, sendBytes[1] + 2, NULL, NULL, 2);
	if (ret)
		return ret;

	return 0;
}

/**
 * Pinpad屏幕行显示
 * @param   clearScreen  0x01 清屏  0x00 不清屏
 * @param   alignment    0x01 左对齐  0x02 中间对齐  0x03 右对齐
 * @param   antiShow     0x00 正常显示  0x01 反显
 * @param   lineNum      行号
 * @param   displayString         显示数据
 * @throws  Exception
 */
static void pinpadDisp(int clearScreen, int alignment, int antiShow, int lineNum, char* displayString)
{
	uchar sendBytes[60];

	int tmp = 0, i;
	sendBytes[tmp++] = 0xE3;
	sendBytes[tmp++] = 0x00;
	sendBytes[tmp++] = 0x05 + strlen(displayString);
	sendBytes[tmp++] =  0x00;
	sendBytes[tmp++] = clearScreen;
	sendBytes[tmp++] = alignment;
	sendBytes[tmp++] = antiShow;
	sendBytes[tmp++] = lineNum;

	for(i = 0; i < strlen(displayString) ; i++){
		sendBytes[tmp++] = displayString[i];
	}
	xydPinpadComm(sendBytes, (sendBytes[1] * 256) + sendBytes[2] + 3, NULL, NULL, 1);
}

/**
 * Pinpad取随机数
 * @param
 * @throws  Exception
 */
static int getRand(uchar *rand)
{
	uchar sendBytes[2];
	uchar receivedBytes[20];

	sendBytes[0] = 0xD0;
	sendBytes[1] = 0x00;
	int receivedLength = 0, i;
	int ret = xydPinpadComm(sendBytes, 2, receivedBytes, &receivedLength, 1);
	if (ret)
		return ret;
	if (receivedLength <= 0)
		//throw new Exception("取随机数出错");
		return 110;

	for (i=0; i<receivedLength; i++)
		rand[i] = receivedBytes[i];

	return 0;
}


static int getAuthCode(uchar* data, int startIndex, int dataLength, uchar mode, uchar *authCode)
{
	uchar authMac[8];
	memset(authMac, 0, sizeof(authMac));

	int i;
	//异或 长度后到authcode前的数据
	for(i = 0; i < dataLength; i++){
		authMac[i % 8] ^= data[startIndex + i];
	}

	//byte[] random = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};
	uchar random[8];

	int ret = getRand(random);
	if (ret)
		return ret;

	//异或随机数
	for(i = 0; i < 8; i++){
		authMac[i] ^= random[i];
	}

	//初始化时不需要异或uid
	if(mode == 0x01) {
		for(i = 0; i < 16; i++){
			authMac[i % 8] ^= uid[i];
		}
	}

	//3DES加密
	//ret = encryptMode(authMac, authCodeKey, authCode);
	encryptMode(authMac, authCodeKey, authCode);

	return 0;
}

static void encryptMode(uchar *sSource, uchar *sKey, uchar *sResult)
{
	uchar sTmp[8];
    _fDes(ENCRYPT, (uchar*)sSource, (uchar*)sKey, sResult);
    _fDes(DECRYPT, (uchar*)sResult, (uchar*)sKey+8, sTmp);
    _fDes(ENCRYPT, (uchar*)sTmp, (uchar*)sKey, sResult);
}

/*
	private String pinpadError(byte errorCode){
		String retStr = null;
		switch(errorCode){
		case (byte)0x01:
			retStr = "协议的长度错误";
			break;
		case (byte)0x02:
			retStr = "密钥校验错误";
			break;
		case (byte)0x03:
			retStr = "打开失败";
			break;
		case (byte)0x04:
			retStr = "关闭失败";
			break;
		case (byte)0x05:
			retStr = "设备操作失败";
			break;
		case (byte)0x06:
			retStr = "超时";
			break;
		case (byte)0x07:
			retStr = "参数错";
			break;
		case (byte)0x08:
			retStr = "认证失败";
			break;
		case (byte)0x09:
			retStr = "连续认证失败次数超过30次，密码键盘被锁定";
			break;
		case (byte)0x0A:
			retStr = "非法初始化";
			break;
		case (byte)0x0B:
			retStr = "非法探测保护";
			break;
		case (byte)0x0D:
			retStr = "EDC错误";
			break;
		case (byte)0x0E:
			retStr = "ESAM操作错误";
			break;
		case (byte)0x0F:
			retStr = "无卡";
			break;
		case (byte)0x21:
			retStr = "执行复位指令操作失败";
			break;
		case (byte)0x31:
			retStr = "错误目录号";
			break;
		case (byte)0x41:
			retStr = "随机数发生错误";
			break;
		case (byte)0x51:
			retStr = "非法主密钥ID或mode";
			break;
		case (byte)0x52:
			retStr = "当前目录错误";
			break;
		case (byte)0x53:
			retStr = "主密钥下载错误";
			break;
		case (byte)0x54:
			retStr = "写数据错";
			break;
		case (byte)0x55:
			retStr = "读数据错";
			break;
		case (byte)0x56:
		case (byte)0x57:
			retStr = "超出存储空间";
			break;
		case (byte)0x61:
			retStr = "工作密钥ID错误";
			break;
		case (byte)0x62:
			retStr = "模式错误";
			break;
		case (byte)0x63:
			retStr = "指定的主密钥模式或ID错";
			break;
		case (byte)0x64:
			retStr = "密钥发散错";
			break;
		case (byte)0x65:
			retStr = "主密钥类型错误";
			break;
		case (byte)0x66:
			retStr = "主密钥截取错";
			break;
		case (byte)0x67:
			retStr = "密钥已经存在";
			break;
		case (byte)0x68:
			retStr = "密钥模式错";
			break;
		case (byte)0x71:
			retStr = "PIN加密密钥超过指定的使用次数";
			break;
		case (byte)0x72:
			retStr = "模式错误";
			break;
		case (byte)0x73:
			retStr = "PIN密钥ID非法";
			break;
		case (byte)0x74:
			retStr = "PIN的位数设置错";
			break;
		case (byte)0x75:
			retStr = "PIN加密错";
			break;
		case (byte)0x76:
			retStr = "PIN输入超时";
			break;
		case (byte)0x77:
			retStr = "用户取消PIN输入";
			break;
		case (byte)0x78:
			retStr = "第一次输入PIN与第二次输入PIN不相同";
			break;
		case (byte)0x79:
			retStr = "PINBLOCK算法设置错";
			break;
		case (byte)0x7A:
			retStr = "PIN输入相邻按键超时";
			break;
		case (byte)0x7B:
			retStr = "PIN 输入长度为0";
			break;
		case (byte)0x7C:
			retStr = "单位小时运算次数超过110次";
			break;
		case (byte)0x7D:
			retStr = "设置使用次数超出最大限制";
			break;
		case (byte)0x81:
			retStr = "加密ID或 mode非法";
			break;
		case (byte)0x82:
			retStr = "数据不是8的整数倍";
			break;
		case (byte)0x83:
			retStr = "MAC计算错误";
			break;
		case (byte) 0x91:
			retStr = "模式错误";
			break;
		case (byte) 0x92:
			retStr = "加解密失败";
			break;
		case (byte)0xA1:
			retStr = "DUKPT Load错";
			break;
		case (byte)0xA2:
			retStr = "计算器溢出";
			break;
		case (byte)0xA3:
			retStr = "更新DUKPT 21个新密钥错误";
			break;
		case (byte)0xA4:
			retStr = "存储DUKPT错误";
			break;
		case (byte)0xA5:
			retStr = "LoadinitKey 错误";
			break;
		case (byte)0xA9:
			retStr = "RTC 设置非法";
			break;
		case (byte)0xAA:
			retStr = "数据长度校验错";
			break;
		case (byte)0xAB:
			retStr = "接收数据内容校验错误";
			break;
		case (byte)0xB1:
			retStr = "RTC 设置失败";
			break;
		case (byte)0xD1:
			retStr = "LOG 操作越界";
			break;
		case (byte)0xE1:
			retStr = "UID 已经下载过了";
			break;
		case (byte) 0xFF:
			retStr = "执行错误";
			break;
		default:
			retStr = "未识别错误" + errorCode;
		}
		return retStr;
	}
	 String piccError(byte errorCode){
		String retStr = null;
		switch(errorCode){
			case 0x01:
				retStr = "协议的长度错误";
				break;
			case 0x02:
				retStr = "激活(上电)前未执行检测卡操作";
				break;
			case 0x03:
				retStr = "感应区中有多于一张的Type PICC卡";
				break;
			case 0x04:
				retStr = "Type A 卡 RATS 失败";
				break;
			case 0x05:
				retStr = "设备操作失败";
				break;
			case 0x06:
				retStr = "无卡";
				break;
			case 0x07:
				retStr = "B 卡激活失败";
				break;
			case 0x0A:
				retStr = "A 卡激活失败(可能多张卡存在)";
				break;
			case 0x0B:
				retStr = "B 卡冲突(可能多张卡存在)";
				break;
			case 0x0C:
				retStr = "A、B卡同时存在";
				break;
			case 0x0F:
				retStr = "不支持 ISO14443-4 协议的卡, 比如 Mifare-1卡";
				break;
			case (byte) 0xFF:
				retStr = "执行错误";
				break;
			default:
				retStr = "未识别错误" + errorCode;
		}
		return retStr;
	}
}
*/


